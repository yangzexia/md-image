# Ventus驱动

## Vortex驱动源代码阅读

### 文件的编译结构

**/vortex/driver/rtlsim/Makefile:**

```makefile
RTLSIM_DIR = ../../sim/rtlsim

CXXFLAGS += -std=c++11 -Wall -Wextra -pedantic -Wfatal-errors

CXXFLAGS += -I../include -I../common -I../../hw -I$(RTLSIM_DIR) -I$(RTLSIM_DIR)/../common

# Position independent code
CXXFLAGS += -fPIC

# Add external configuration
CXXFLAGS += $(CONFIGS)

# Dump perf stats
CXXFLAGS += -DDUMP_PERF_STATS

LDFLAGS += -shared -pthread
# 将目录 . 加入到搜索库文件的目录
# 在库文件搜索路径中寻找 librtlsim.so 动态库文件
LDFLAGS += -L. -lrtlsim
SRCS = vortex.cpp ../common/vx_utils.cpp
PROJECT = libvortex.so

all: $(PROJECT)

$(PROJECT): $(SRCS)
    DESTDIR=../../driver/rtlsim $(MAKE) -C $(RTLSIM_DIR) ../../driver/rtlsim/librtlsim.so
    $(CXX) $(CXXFLAGS) $(SRCS) $(LDFLAGS) -o $(PROJECT)

clean:
    DESTDIR=../../driver/rtlsim $(MAKE) -C $(RTLSIM_DIR) clean
    rm -rf $(PROJECT) *.o
```

先编译了`/vortex/sim/rtlsim/Makefile`,生成了librtlsim.so, 该动态库文件随后作为链接选项，编译`$(SRCS)`, 生成了libvortex.so，用于OpenCL程序在编译时链接

## driver与Verilator

通常情况下，Verilator的工作流程如下所示：

1. 首先Verilator将读取特定的HDL文件并检查其代码，同时还可以选择支持检查覆盖率和debug波形的生成。然后将源文件编译成源代码级的多线程(source level multithreaded) `C++`或`SystemC`模型。其输出的模型会以`.cpp`和`.h`文件存在。这个阶段的过程叫做"to Varilate"，输出的文件叫做"Verilated Model"。
2. 为了能够完成仿真，Verilator需要一个用户自行编写的C++ wrapper，这个wrapper与传统的Verilog Testbench 功能类似，主要是为了连接顶层模块，并给予相应的激励。
3. 在C++ 编译器的工作下，所有的之前生成的文件（C++ wrapper以及Verilated Model）以及库文件（Verilator提供的runtime library或者SystemC库文件）会被一同合并成一个可执行文件。
4. 执行生成的可执行文件，就可以开始实际的仿真，此时成为"simulation runtime"
5. 最后如果在编译阶段将特定的编译选项打开，可执行文件也会生成波形和覆盖率等信息。

Vortex的rtl代码顶层为`Vortex.sv`，在verilator编译之后生成名为`VVortex.h`和`VVortex.cpp`的`C++`代码，以及其他模块的相关代码，在C++代码中，rtl中实现的模块以类的形式存在，并增添了一些用于执行的方法。在vortex的driver中，例化了顶层模块对应的类，模块之间的连接关系变为对类的成员变量的赋值。

**verilator提供的API**

```cpp
//在输入改变时必须调用该接口，评估模型
void eval(){ eval_step(); }
//每个时间步调用多个单元时，用于评估
void eval_step()
//必须在所有的eval()调用之后以及始终改变之前调用
void eval_end_step()
//仿真结束，运行最后的模块，在完成时必须调用
void final()
```

在verilator生成的C++中，模块的端口为类的公有变量，包括时钟。



### 程序执行流程

对于一个测试程序，例如tests文件夹下的测试程序，主要有以下几个流程，代码块内为主要用到的函数和变量：

1. 分配一个新设备`vx_dev_open()`，并设置相关参数（核心数量，block数量，buffer大小）

2. 为设备分配内存`vx_mem_alloc()`并记录内存的起始地址和结束地址到结构体`kernel_arg`
    > 这一步调用了`vx_device::mem_allocator_::allocate()`

3. 分配共享内存`vx_buf_alloc()`

4. 将kernel file上传到设备`vx_upload_kernel_file()`
   > 这一步最终调用了`vx_device::ram_::write()`

5. 将kernel参数上传到设备`vx_copy_to_dev()`
   > 这一步最终调用了`vx_device::ram_::write()`

6. 更新源缓冲区，清空目标缓冲区（通过向设备的配置寄存器写数据`vx_copy_to_dev()`）

7. 开始执行`vx_start()`，等待设备执行完后ready,`vx_ready_wait()`

8. 读目标缓冲区`vx_copy_from_dev()`

9.  验证执行结果,使用了在main()函数中定义的`run_kernel_test()`

### 类之间的关系



 # 22.12.13进度

- [ ] 修改多任务的代码，输入为一个kernel需要的block数量，需要修改wg_id为：{kernel_id，block_id（从零开始递增），5'b0}，每个kernel对应一个PTBR，PTBR通过硬连线传入硬件，后续硬件会改
  - [ ] 多个kernel的情况，kernel_id从零开始递增
  - [ ] block完成之后会返回一个block_id，
- [ ] 一系列约定：buffer大小，buffer（kernel参数）存在哪个地址，
